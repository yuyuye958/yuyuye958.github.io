<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript面向对象编程]]></title>
    <url>%2F2018%2F10%2F12%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[什么是面向对象面向对象程序设计（Object-oriented programming，简称OOP），概念如下： 把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）／泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派（dynamic dispatch）。 上面这段话根本看不懂什么意思，还是先来理解一下面向对象的一些术语吧： Class 类定义对象的特征。它是对象的属性和方法的模板定义.Object 对象类的一个实例。Property 属性对象的特征，比如颜色。Method 方法对象的能力，比如行走。Constructor 构造函数对象初始化的瞬间, 被调用的方法. 通常它的名字与包含它的类一致.Inheritance 继承一个类可以继承另一个类的特征。Encapsulation 封装一种把数据和相关的方法绑定在一起使用的方法.Abstraction 抽象结合复杂的继承，方法，属性的对象能够模拟现实的模型。Polymorphism 多态多意为‘许多’，态意为‘形态’。不同类可以定义相同的方法或属性。 面向对象的四个核心概念：抽象、继承、封装、多态 。 命名空间与其他面向对象编程语言不同，Javascript中创建普通对象和命名空间在写法上没有区别。比如var MySpace = {}，从语言层面上，可以理解成创建了一个名为MySpace的对象，也可以理解为一个名为MySpace的命名空间，到底应该理解成哪一种主要是看你如何使用它。 JavaScript命名空间：一个全局对象被创建，所有的变量，方法和功能成为该对象的属性。使用命名空间也最大程度地减少应用程序的名称冲突的可能性。 举例：我们来创建一个全局变量叫做 examplevar example = example || {};在上面的代码示例中，我们首先检查example是否已经被定义。如果是的话，那么使用现有的example全局对象；否则，创建一个名为example的空对象用来封装方法，函数，变量和对象。然后我们就可以创建子命名空间：example.event = {}; 类JavaScript是一种基于原型的语言。JavaScript可封装一个函数作类。举例：12function Person() &#123; &#125; var Person = function()&#123; &#125; // 也可以这么写 对象（类的实例）我们使用 new obj 创建对象obj 的新实例, 将结果（obj 类型）赋值给一个变量方便稍后调用。举例：我们定义了一个名为Person的类，然后我们创建了两个Person的实例(person1 和 person2).123function Person() &#123; &#125;var person1 = new Person();var person2 = new Person(); 构造函数 “类”就是对象的模板，对象就是“类”的实例。 JavaScript 语言的对象体系，基于构造函数（constructor）和原型链（prototype）。 JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓构造函数，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。例如：123function Person(name) &#123; // 这就是一个构造函数 this.name = name; &#125; 为了与普通函数区别，构造函数名字的第一个字母通常大写。 构造函数的特点有两个： 函数体内部使用了this关键字，代表了所要生成的对象实例。 生成对象的时候，必须使用new命令。 下面将详细介绍一下new命令和this关键字。 new 命令new命令的作用，就是执行构造函数，返回一个实例对象。ES6有 class 关键字，我们先用ES5使用函数来模拟类：1234567891011function Person(name) &#123; this.name = name; &#125;Person.prototype.sayHello = function()&#123; console.log( 'Hi, I am ' + this.name)&#125;var allen = new Person('Allen')allen.sayHello // Hi, I am Allen 上面代码通过new命令，让构造函数Person生成一个实例对象，保存在变量allen中。这个新生成的实例对象，从构造函数Person得到了name属性和sayHello方法。 使用new，JS其实默默做了这些事情： var 临时对象 = {} 临时对象.__proto__ = Person.prototype // 帮我绑定原型 临时对象.name = name return 临时对象 例子：1234function fn()&#123; console.log(this)&#125;new fn() 请问这个 this 有哪些属性？这个 this 的原型有哪些属性？this 有属性：__proto__ (指向fn.prototype)原型的属性有constructor: fn 和 __proto__(指向Object.prototype) this关键字 什么是this，最本质的概念是：this就是你 call 一个函数时，传入的第一个参数。 如果是封装过的函数（比如onclick()、addEventListener()等），如何判断this 看源码中对应的函数是怎么被 call 的（这是最靠谱的办法） 看文档 console.log(this) 不要瞎猜，很可能猜错 this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。 例子1：123456function a()&#123; var user = 'Allen'; console.log(this.user); //undefined console.log(this); //Window&#125;a(); 例子2：12345678910111213141516171819202122function X() &#123; return obj = &#123; name:'obj', fn1(x) &#123; x.fn2() &#125;, fn2() &#123; console.log(1) console.log(this) &#125; &#125;&#125;var options = &#123; name:'options', fn1() &#123;&#125;, fn2() &#123; console.log(2) // 执行的是这里 打印2 console.log(this) // 执行的是这里 打印options对象 &#125;&#125;var x = X()x.fn1(options) 记住，this永远指向的是最后调用它的对象。 例子3：123456789101112131415function fn1() &#123; this.user = 'Allen'; return &#123;&#125;; &#125;var a = new fn1; console.log(a.user); //undefinedfunction fn2() &#123; this.user = 'Allen'; return 1;&#125;var a = new fn2; console.log(a.user); //Allen 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的MVC设计模式]]></title>
    <url>%2F2018%2F10%2F10%2FMVC%2F</url>
    <content type="text"><![CDATA[JavaScript中的MVCMVC模式（Model–view–controller）是一种设计模式（或者软件架构），把系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。 Model 数据管理，主要负责和服务器进行交互。将请求到的数据传给Controller。 View 负责用户界面，HTML 渲染。 Controller 负责监听并处理View 的事件，更新和调用 Model；也负责监听 Model的变化（Model从服务器获得数据），并更新 View。Controller 控制其他所有流程。 画图来理解： Model 和服务器交互，Model 将得到的数据交给 Controller，Controller 把数据填入 View，并监听 View用户操作 View，如点击按钮，Controller 就会接受到点击事件，Controller 这时会去调用 Model，Model 会与服务器交互，得到数据后返回给 Controller，Controller 得到数据就去更新 View MVC模式的优点就我的理解来说，MVC模式有这些好处： 低耦合性。每层各司其职，比如只需要改变视图层而不需要重新编译模型和控制器代码，改代码不用在各个部分改，只需要改变某部分的代码。 方便维护和修改。视图层、数据层和业务逻辑层分开，结构清晰好理解。 大大提高代码的可重用性。比如用不同的视图层访问模型的数据，只要在控制器层对数据格式做处理，而不需要修改模型层的代码。 具体例子代码链接：https://github.com/yuyuye958/resume/blob/master/js/message.js 这段代码实现使用leanCloud的库来做留言板的功能。 另外关于这段代码使用的立即执行函数和闭包，再介绍些题外话。 如何使用立即执行函数 我们不想要全局变量 我们要使用局部变量 ES 5 里面，只有函数有局部变量 于是我们声明一个 function xxx，然后 xxx.call() 这个时候 xxx 是全局变量（全局函数） 所以我们不能给这个函数名字 function(){}.call() 但是这样写 Chrome 会报错，语法错误 试出来一种方法可以不报错:12345678!function()&#123;&#125;.call() //我们不在乎这个匿名函数的返回值，所以加个 ! 取反没关系(function()&#123;&#125;).call() //不推荐xxx (function()&#123;&#125;).call() //报错allen12415145141556.call() //用随机数，不推荐 如何使用闭包 立即执行函数使得 变量person 无法被外部访问 闭包使得匿名函数可以操作 变量person window.GrowUp 保存了匿名函数的地址 任何地方都可以使用 window.GrowUp=&gt; 任何地方都可以使用 window.GrowUp 操作 person，但是不能直接访问 person123456!function()&#123; var person = xxx window.GrowUp()&#123; xxxxx &#125;&#125;.call()]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS封装jQuery的AJAX]]></title>
    <url>%2F2018%2F10%2F08%2FjQuery-AJAX%2F</url>
    <content type="text"><![CDATA[基本功能设置请求request第一步 let request = new XMLHttpRequest()第一部分：request.open(&#39;GET&#39;, &#39;/xxx&#39;)第二部分：(不能设置User-Agent，会报错)request.setRequestHeader(&#39;Content-Type&#39;, &#39;x-www-form-urlencoded&#39;)第四部分：request.send(&#39;a=0&amp;b=1&#39;) 获取响应response第一部分：获取HTTP状态request.status //200request.statusText //OK 第二部分：获取响应headerrequest.getAllResponseHeaders() //获取第二部分所有内容request.getResponseHeader(&#39;Content-Type&#39;) //获取Content-Type 的内容 第四部分：request.responseText() 封装jQuery.ajax初始版本封装：123456789101112131415161718192021222324252627window.jQuery.ajax = function(options)&#123; let url = options.url let method = options.method let body = options.body let successFn = options.successFn let failFn = options.failFn let headers = options.headers let request = new XMLHttpRequest() request.open(method, url) //初始化请求 for(let key in headers)&#123; let value = headers[key] request.setRequestHeader(key, value) &#125; request.onreadystatechange = () =&gt;&#123; if(request.readyState === 4)&#123; if(request.status &gt;= 200 &amp;&amp; request.status &lt;= 300)&#123; successFn.call(undefined, request.responseText) &#125;else if(request.status &gt;= 400)&#123; failFn.call(undefined, request) &#125; &#125; &#125; request.send(body) //发送请求&#125;window.$ = window.jQuery 调用：1234567891011121314151617myButton.addEventListener('click', (e) =&gt;&#123; window.jQuery.ajax(&#123; url: '/xxx', method: 'post', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'allen': '23' &#125; , body: 'a=0&amp;b=1', successFn: (x) =&gt; &#123;console.log(x)&#125;, failFn: (x) =&gt; &#123; console.log(x) console.log(x.statusText) console.log(x.responseText) //请求失败也可以获取第四部分 &#125; &#125;)&#125;) 此时代码很傻，下面来优化一下。 使用ES6语法解构赋值ES6新语法之解构赋值，见MDN文档 。优化后的代码：123456789101112131415161718window.jQuery.ajax = function(&#123;url, method, body, successFn, failFn, headers&#125;)&#123; //解构赋值语法 let request = new XMLHttpRequest() request.open(method, url) //初始化请求 for(let key in headers)&#123; let value = headers[key] request.setRequestHeader(key, value) &#125; request.onreadystatechange = () =&gt;&#123; if(request.readyState === 4)&#123; if(request.status &gt;= 200 &amp;&amp; request.status &lt;= 300)&#123; successFn.call(undefined, request.responseText) &#125;else if(request.status &gt;= 400)&#123; failFn.call(undefined, request) &#125; &#125; &#125; request.send(body) //发送请求&#125; 使用promise优化因为每个程序员的回调名不一样，你不看文档根本不知道这个库的函数名是什么，所以我们可以使用该方法不设置successFn、failFn这两个函数的函数名。返回一个promise对象，传入的两个参数resolve、reject，分别代表成功时执行的内容和失败时执行的内容。 再次优化后的代码：1234567891011121314151617181920window.jQuery.ajax = function(&#123;url, method, body, headers&#125;)&#123; return new Promise(function(resolve, reject)&#123; // 这行代码要记住 let request = new XMLHttpRequest() request.open(method, url) //初始化请求 for(let key in headers)&#123; let value = headers[key] request.setRequestHeader(key, value) &#125; request.onreadystatechange = () =&gt;&#123; if(request.readyState === 4)&#123; if(request.status &gt;= 200 &amp;&amp; request.status &lt;= 300)&#123; resolve.call(undefined, request.responseText) &#125;else if(request.status &gt;= 400)&#123; reject.call(undefined, request) &#125; &#125; &#125; request.send(body) //发送请求 &#125;)&#125; 调用：12345678910111213141516 window.jQuery.ajax(&#123; url: '/xxx', method: 'post', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'allen': '23' &#125; &#125;).then( (responseText) =&gt; &#123; console.log(responseText); return responseText; &#125;, (request) =&gt; &#123; console.log('error'); return 'error' &#125;) then返回也是promise对象，于是就有了链式操作。 jQuery本身的ajax方法上面是我们模仿jQuery自己封装的ajax方法，下面来看看jQuery真正的ajax方法。举例：123456789101112131415161718$.ajax(&#123; url:'/xxx', method: 'post', dataType:'x-www-form-urlencoded', data:'a=0&amp;b=1', success:(responseText)=&gt;&#123;console.log(responseText)&#125;, error:(e)=&gt;&#123;console.log('error')&#125;&#125;)$.ajax(&#123; url:'/xxx', method: 'post', dataType:'json', data:'a=0&amp;b=1',&#125;).then( (responseText)=&gt;&#123;console.log(responseText)&#125;, (e)=&gt;&#123;console.log('error')&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX是什么？]]></title>
    <url>%2F2018%2F10%2F06%2FAJAX%2F</url>
    <content type="text"><![CDATA[AJAX的发展历史历史上发送请求的方式用 form 可以发请求，但是会刷新页面或新开页面用 a 可以发 get 请求，但是也会刷新页面或新开页面用 img 可以发 get 请求，但是只能以图片的形式展示用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示用 script 可以发 get 请求，但是只能以脚本的形式运行以上都除了form都只能发get请求 所以需要一个能发任何请求（GET,POST,PUT,DELETE）并且想以什么形式展现就以什么形式展示的方法。后来就有了AJAX。 XMLHttpRequest的发明微软当时取得了重大突破：IE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。随后 Mozilla、 Safari、 Opera 也跟进了，取名 XMLHttpRequest，并被纳入 W3C 规范 AJAXJesse James Garrett 将下面的技术取名叫做 AJAX：异步的 JavaScript 和 XML (async JavaScript and XML) 使用XMLHttpRequest发请求 服务器返回XML格式的字符串 JS解析XML，并局部更新页面 123456789101112let request = new XMLHttpRequest() request.onreadystatechange = () =&gt;&#123; //尽量放在最上面，这样就不会错过任何变化， if(request.readyState === 4)&#123; //如果放在request.send()之后，这时候readyState已经从0变为1，就只能捕获到2，3，4。 if(request.status &gt;= 200 &amp;&amp; request.status &lt;= 300)&#123; console.log('请求成功') &#125;else if(request.status &gt;= 400)&#123; console.log('请求失败') &#125; &#125; &#125; request.open('GET', '/xxx') //初始化请求 request.send() //发送请求 readyState：请求的五种状态0： 未打开 open()方法还未被调用1： 未发送 send()方法还未被调用2： 已经获取响应头 send()方法已经被调用，响应头和响应状态已经返回3： 正在下载响应体 响应体下载中；responseText中已经获取了部分数据4： 请求完成 整个请求过程完成 JSONJSON 是一门抄袭/借鉴 JavaScript 的语言，同时也是一种数据交互格式，JSON 是 JavaScript 的子集（或者说 JSON 只抄袭了一部分 JavaScript 语法，而且没有新增任何原创的语法）区别：JSON 不支持函数、undefined、变量、引用、单引号字符串、对象的key不支持单引号也不支持不加引号、没有内置的 Date、Math、RegExp 等。而 JavaScript 全都支持。 JavaScript JSON undefined 无 null null [‘a’, ‘b’] [“a”, “b”] ‘allen’ “allen” {name: ‘allen’} {“name”: “allen”} function fn(){} 无 var a = {};a.self = a 无 &#95;&#95;proto&#95;&#95; 无 那么现在再结合前后端一起看一下代码后端代码：12345678910111213141516if(path==='/xxx')&#123; response.statusCode = 200 response.setHeader('Content-Type', 'text/json;charset=utf-8') response.setHeader('Access-Control-Allow-Origin', 'http://frank.com:8001') response.write(` &#123; "note":&#123; "to": "frank", "from": "allens", "heading": "打招呼", "content": "hello" &#125; &#125; `) response.end()&#125; 前端代码：1234567891011121314151617181920212223myButton.addEventListener('click', (e)=&gt;&#123; let request = new XMLHttpRequest() request.open('get', '/xxx') // 配置request request.send() request.onreadystatechange = ()=&gt;&#123; if(request.readyState === 4)&#123; console.log('请求响应都完毕了') if(request.status &gt;= 200 &amp;&amp; request.status &lt; 300)&#123; console.log('请求成功') console.log(request.responseText) let string = request.responseText // 把符合 JSON 语法的字符串 // 转换成 JS 对应的值 let object = window.JSON.parse(string) //JSON.parse()浏览器提供 console.log(typeof object) console.log(object) console.log(object.note) &#125;else if(request.status &gt;= 400)&#123; console.log('请求失败') &#125; &#125; &#125;&#125;) 同源策略和CORS跨域同源策略的本质是：一个域名的JS，在未经允许的情况下，不能读取另一个域名的内容，但你可以向另一个域名发送请求。 只有 协议+端口+域名 一模一样才允许发 AJAX 请求 CORS 可以告诉浏览器，我俩一家的，别阻止他 突破同源策略 === 跨域 后端代码：123//加入响应头response.setHeader('Access-Control-Allow-Origin', 'http://allen.com:8001') //允许http://allen.com:8001向我发起请求response.setHeader('Access-Control-Allow-Origin', '*') //允许所有域名向我发起请求]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP是什么？]]></title>
    <url>%2F2018%2F10%2F06%2FJSONP%2F</url>
    <content type="text"><![CDATA[以前是如何发送请求的？有一些HTML标签能发送请求，比如&lt;form&gt;标签、&lt;a&gt;标签、&lt;link&gt;标签、&lt;script&gt;标签、&lt;img&gt;标签。 我们引入一个例子来说明：用户每点击一下付款按钮，页面和数据库中的余额减少1。 使用form表单123456&lt;body&gt; &lt;h5&gt;你的账户余额为&lt;span id="amount"&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/h5&gt; &lt;form action="/pay" method="post"&gt; &lt;input type="submit" value="付款1块钱"&gt; &lt;/form&gt;&lt;/body&gt; form表单一旦提交就会自动刷新页面，进入pay页面，需要用户退回index页面，刷新页面才能看到结果。而a标签也会刷新页面或打开新页面。这样的用户体验很差，程序员就想办法怎么样才能发送请求并局部刷新页面。 使用form + iframe1234567&lt;body&gt; &lt;h5&gt;你的账户余额为&lt;span id="amount"&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/h5&gt; &lt;form action="/pay" method="post" target="result"&gt; &lt;input type="submit" value="付款1块钱"&gt; &lt;/form&gt; &lt;iframe src="about:blank" frameborder="0" name="result" height="200"&gt;&lt;/iframe&gt;&lt;/body&gt; 这种方法发送请求后不会自动跳转页面，但余额部分不会局部刷新，这也是过时的方法了。 动态创建图片1234567891011121314151617&lt;body&gt; &lt;h5&gt;你的账户余额为&lt;span id="amount"&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/h5&gt; &lt;button id="button"&gt;付款1块钱&lt;/button&gt; &lt;script&gt; button.addEventListener('click', (e) =&gt;&#123; let image = document.createElement('img') image.src = '/pay' image.onload = function () &#123; alert('打钱成功') window.location.reload() //刷新页面 &#125; image.onerror = function () &#123; alert('打钱失败') &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 这样子发送请求虽然能成功(浏览器控制台中返回了200状态码)，但实际上仍显示打钱失败，这是为什么呢？因为后端代码中返回的不是真正的图片，被浏览器识别出来，导致image.onerror执行，如果使用的是真图片就会执行image.onload。所以后端必须返回一个图片。 另外img标签还有一个弊端是只能发起GET请求不是发起POST请求。 动态创建script123456789101112131415161718&lt;body&gt; &lt;h5&gt;你的账户余额为&lt;span id="amount"&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/h5&gt; &lt;button id="button"&gt;付款1块钱&lt;/button&gt; &lt;script&gt; button.addEventListener('click', (e) =&gt;&#123; let script = document.createElement('script') script.src = '/pay' document.body.appendChild(script) script.onload = function()&#123; alert('success') window.location.reload() //刷新页面 &#125; script.onerror = function()&#123; alert('fail') &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 动态创建img不用放入页面就能发起请求，而script必须要放入页面才能发起请求 因为这种方法会在页面中放入一个script，那么里面的内容就会执行，所以我们可以不用监听script.onload，直接在后端返回的script中写入我们要执行的代码。node.js: 12response.write(`alert('success') window.location.reload()`) 页面中会插入script，那么在请求成功后应该删除script （SRJ） 123script.onload = function(e)&#123; e.currentTarget.remove()&#125; script实际上依然存在于内存，只是在页面中消失了 原生JS：1234567891011121314151617181920212223button.addEventListener('click',(e)=&gt;&#123; let script = document.createElement('script'); let functionName = 'allen'+parseInt(Math.random()*100000,10); window[functionName] = function (result) &#123; if(result === 'success')&#123; amount.innerText = amount.innerText - 1 &#125;else &#123; alert(`fail`) &#125; &#125;; script.src = 'http://jack.com:8002/pay?callback=' + functionName; document.body.appendChild(script); script.onload = function (e) &#123; e.currentTarget.remove(); delete window[functionName] &#125;; script.onerror = function (e) &#123; alert('fail'); e.currentTarget.remove(); delete window[functionName] &#125;&#125;); 这种方法可以跨域请求。比如能在xxx.com中请求zzz.com的JS，但因为script请求只能GET，很不安全，隐私相关的重要操作还是需要使用POST请求。 附server代码：https://github.com/yuyuye958/git-nodejs/blob/master/server.js 所以JSONP到底是什么？请求方：allen.com的前端程序员（浏览器）响应方：frank.com的后端程序员（服务器） 请求方创建script，src指向响应方，同时传一个查询参数 ?callbackName=xxx 响应方根据查询参数callbackName，构造形如 i. xxx.call(undefined, ‘你要的数据’)ii. xxx(‘你要的数据’)这样的响应 浏览器接收到响应，就会执行xxx.call(undefined, ‘你要的数据’) 那么请求方就知道了他要的数据这就是JSONP 约定： callbackName -&gt; callback / jQuery_callback xxx -&gt; 随机数 如allen16516541644464() jQuery 用法123456789$.ajax(&#123;url: "http://jack.com:8002/pay",dataType: "jsonp",success: function( response ) &#123; if(response === 'success') &#123; amount.innerText = amount.innerText - 1 &#125; &#125;&#125;) 注意JSONP不是ajax JSONP 为什么不支持 POST 因为 JSONP 是通过动态创建 script 实现的 创建 script 只能发送 get 请求]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模仿jQuery实现一个API]]></title>
    <url>%2F2018%2F09%2F29%2FjQuery%2F</url>
    <content type="text"><![CDATA[如何模仿jQuery实现一个API？jQuery是一个 JavaScript 库，核心理念是 - write less, do more。其实jQuery就是一个函数，里面封装了很多方法，我们通过这些方法来获取节点(元素)并进行操作，大大方便了我们的编程。 那么关于下面的代码，如何实现类似jQuery提供的api呢？123456window.jQuery = ???window.$ = jQueryvar $div = $('div')$div.addClass(['red','blue']) // 可将所有 div 的 class 添加 red 和 blue 注意这里是数组的写法$div.setText('hi') // 可将所有 div 的 textContent 变为 hi 首先获取对象 123456789101112131415161718window.jQuery = function(nodeOrSelector)&#123; let nodes = &#123;&#125; //初始化对象 //判断用户想获取一个还是多个节点 if(typeof nodeOrSelector === 'string')&#123; //多个节点 let temp = document.querySelectorAll(nodeOrSelector) // 伪数组 //遍历临时对象temp，将它的值放入nodes内，得到一个纯净的伪数组，原型链指向Object for(let i=0;i&lt;temp.length;i++)&#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125; else if(nodeOrSelector instanceof Node)&#123; //一个节点 nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; return nodes //返回nodes&#125; 添加addClass方法 123456789nodes.addClass = function(classes)&#123; // 用户在addClass中输入的是数组所以用forEach classes.forEach((value) =&gt;&#123; //遍历nodes，为nodes内每一个元素节点添加class for(let i = 0 ; i&lt;nodes.length; i++)&#123; nodes[i] .classList.add(value) &#125; &#125;)&#125; 添加setText方法 123456nodes.setText = function(text)&#123; //遍历nodes，为nodes内每一个元素节点的textContent添加text for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].textContent = text &#125;&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536window.jQuery = function(nodeOrSelector)&#123; let nodes = &#123;&#125; if(typeof nodeOrSelector === 'string')&#123; let temp = document.querySelectorAll(nodeOrSelector) for(let i=0;i&lt;temp.length;i++)&#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125; else if(nodeOrSelector instanceof Node)&#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; nodes.addClass = function(classes)&#123; classes.forEach((value) =&gt;&#123; for(let i = 0 ; i&lt;nodes.length; i++)&#123; nodes[i] .classList.add(value) &#125; &#125;) &#125; nodes.setText = function(text)&#123; for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].textContent = text &#125; &#125; return nodes&#125;window.$ = jQueryvar $div = $('div')$div.addClass(['red','blue']) // 可将所有 div 的 class 添加 red 和 blue$div.setText('hi') // 可将所有 div 的 textContent 变为 hi 完成，另外以上代码还使用到了JS的闭包。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的函数]]></title>
    <url>%2F2018%2F09%2F27%2FJS%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[什么是函数函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。函数的本质就是对象，或者说可以执行代码的对象就是函数。 函数的五种声明方法函数体内部的return语句，表示返回。JavaScript 引擎遇到return语句，就直接返回return后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，return语句所带的那个表达式，就是函数的返回值。如果没有return，该函数就返回undefined。 具名函数123function fn1() &#123; return undefined; // 如果不写return ，浏览器默认返回undefined&#125; 匿名函数 1var fn2 = function() &#123;&#125; 结合上面两种方式(谨慎使用) 1var fn3 = function fn4() &#123;&#125; 使用Function函数对象new Function() 中，最后一个参数表示函数体，前面的参数表示传入函数的参数。 12345var fn5 = new Function( 'x', 'y', 'return x + y'); 箭头函数 123var fn6 = (x,y) =&gt; &#123;return x+y&#125; // 箭头前面表示传入函数的参数，箭头后面表示函数体。var fn7 = x =&gt; &#123;return x*2&#125; // 如果只有一个参数，参数的圆括号可以省略var fn8 = x =&gt; x*x // 如果函数体只有一句话，可以同时省略函数体的大括号及return 函数的调用12function fn()&#123; return undefined; &#125;fn() // 执行该函数。 作为初学者，更建议使用call()方法，call()的第一个参数是this，后面的参数是arguments(伪数组)例如：12function fn(x,y)&#123; return x+y; &#125;fn.call(undefined,1,2) // 结果为3 等价于fn(1,2) 函数的常用属性和方法 name 属性每一个函数都有name属性，但其值可能因不同的函数声明方式而不同。举例： 12345678910111213141516171819// 具名函数的name属性，表示函数的名字function fn1() &#123;&#125; fn1.name // "fn1"// 匿名函数的name属性，指的是接收函数的变量名var fn2 = function () &#123;&#125; fn2.name // "fn2"// fn3.name返回函数表达式的名字。真正的函数名还是fn3，而fn4这个名字只在函数体内部可用。var fn3 = function fn4()&#123;&#125; fn3.name // "fn4"// 使用Function()方法构造函数，函数的name属性值为"anonymous"var fn5 = new Function()fn5.name // "anonymous"// 箭头函数的name属性，指的也是接收函数的变量名var fn6 = () =&gt; &#123;&#125;fn6.name // "fn6" length 属性函数的length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。常用来判断定义时和调用时参数的差异 12function fn(a, b) &#123;&#125;fn.length // 2 不管调用时输入了多少个参数，length属性始终等于2。 toString() 方法函数的toString方法返回一个字符串，内容是函数的源码，包括函数中的注释也会被打印出来。 123456789101112function fn() &#123; var a = 1/* 我是 注释*/&#125;fn.toString()// "function fn() &#123;// var a = 1// /* 我是// 注释*/// &#125;" call apply bind 的用法call() 方法调用一个函数, 其具有一个指定的this值和分别地提供的参数(参数的列表)。apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 apply和call二者作用一样，只是接受参数的方式不一样，call需要把参数按顺序传递进去，而apply则是把参数放在数组里。 bind() 方法创建一个新的函数，被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 bind 是创建对应函数，非立即执行；apply 、call会立即执行函数 。 作用域作用域（scope）指的是变量存在的范围。在 ES5 的规范中，Javascript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6又新增了块级作用域。 在判断作用域时，还要注意函数作用域内部会产生变量提升现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。 闭包如果一个函数使用了它范围外的变量，那么（这个函数和这个变量）就叫做闭包。具体介绍这里引用链接:https://zhuanlan.zhihu.com/p/22486908 回调（callback）名词解释：被当做参数的函数就是回调函数动词解释：调用这个回调举例：fn(function(){}) ：函数fn中的参数是一个函数，在fn中调用了这个函数，那么这个函数就是回调函数，调用的过程就是回调。 立即执行函数的使用我的MVC篇中有用到立即执行函数，并有详细讲解。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中的数组]]></title>
    <url>%2F2018%2F09%2F26%2FJS%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组是什么数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。其实本质上，数组属于一种特殊的对象。typeof运算符会返回数组的类型是object。 数组的length属性数组的length属性，返回数组的成员数量。只要是数组，就一定有length属性。 数组的构造方法123var x = new Array(3) ; // 3表示数组的长度，每一个元素都为undefinedvar y = new Array(3,3); // 得到一个数组[3,3]，是仿自Java中的写法，不常用。var a = [3,3] ; // 得到了一个数组[3,3]，常用 in 运算符 &amp;&amp; for…in 循环for in循环不仅可以遍历对象，也可以遍历数组，因为数组是一种特殊对象。 使用时需要注意，for…in不仅会遍历数组所有的数字键，还会遍历非数字键。 例如：12345678910var a = [1, 2, 3];a.foo = true;for (var key in a) &#123; console.log(key);&#125;// 0// 1// 2// foo 数组的遍历常用for循环，while循环或forEach遍历(不支持break 和 continue ，不返回值)。12345678910111213141516171819202122var a = ['a','b','c','d'];// for循环for(var i = 0; i &lt; a.length; i++) &#123; console.log(a[i]);&#125;// while循环var i = 0;while (i &lt; a.length) &#123; console.log(a[i]); i++;&#125;// forEach遍历a.forEach(function(value,key)&#123; console.log(key+':'+value);&#125;)// 0:a// 1:b// 2:c// 3:d 什么是伪数组如果一个对象的所有键名都是正整数或零，并且有length属性，那么这个对象就很像数组，但实际并不是数组。 伪数组的原型链中没有Array.prototype 12数组.__proto__ === Array.protype伪数组对象.__proto__ === Object.prototype 数组的一些APIsort() 排序该方法是JS封装的一个重排序方法，使用的算法是快速排序。不传参时默认为升序排列。注：sort()方法返回的是原数组，即使用该方法会改变原来的数组序列。=&gt;arr.sort(function(a,b){return a-b}) 升序=&gt;arr.sort(function(a,b){return b-a}) 降序 join() 分隔该方法返回的是字符串，参数表示用什么分隔数组的每一项，不传参默认逗号分隔，参数为空数组时，数组每一项之间没有间隔。代码示例：123array = ["a", "b", "c", "d"];array.join('-');// "a-b-c-d" concat() 连接该方法返回的是新数组，原数组不会被改变。示例：1234a = [1,2,3];b = [4,5,6];a.concat(b);// 新数组 [1, 2, 3, 4, 5, 6] 使用concat()方法还可以用于复制数组例如：12345arr = [1,2,3,4,5];var newArr = arr.concat([]);// newArr 的值为 [1, 2, 3, 4, 5]newArr === arr; // false// 虽然值相同，但这是两个不同的对象，引用的地址不同 map()功能与forEach相同，但map()有返回值。同样不会改变原数组的值，返回一个新数组。示例：12345arr = [1, 2, 3, 4, 5];arr.map(function(value,key)&#123; return value * 2;&#125;)// [2, 4, 6, 8, 10] filter() 过滤、筛选用法与map()一样。示例：12345arr = [1, 2, 3, 4, 5];arr.filter(function(value,key)&#123; return value &lt; 3&#125;)// [1, 2] reduce() 可接收一个函数作为累加器第一个参数传一个函数作为累加器，第二个参数表示初始值。示例：12345arr = [1, 2, 3, 4, 5];arr.reduce(function(previous,current)&#123; return previous + current;&#125;, 0)// 15 可以用reduce()方法来写map()数组每一项×2：123456a = [1, 2, 3, 4, 5];a.reduce(function(array,n)&#123; array.push(n * 2); return array;&#125;,[])// [2, 4, 6, 8, 10] 可以用reduce()方法来写filter()筛选偶数：12345678a = [1, 2, 3, 4, 5];a.reduce(function(array,n)&#123; if(n % 2 === 0)&#123; array.push(n); &#125; return array;&#125;,[])// [2, 4]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型与原型链]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[全局函数 Number12var n1 = 1var n2 = new Number(1) // 创建一个 Number 对象 两者的区别是什么？前者将数据直接存在 Stack 里，后者实际上是一个哈希对象，把 Heap 地址存在 Stack 里。 但是前者没有toString()属性，为什么n1.toString()的结果是&#39;1&#39;？JS引擎会建立一个临时的对象， 12temp = new Number(n1)temp.toString() 然后再把temp回收掉，所以几乎没人用第二种写法。 String 12var s1 = 'hello'var s2 = new String('hello') // 创建一个 String 对象 和Number同理。 Boolean 12var b1 = truevar b2 = new Boolean(true) // 创建一个 Boolean 对象 和Number同理。 Object 12var o1 = &#123;&#125;var o2 = new Object() o1 和 o2 没区别，不过ol === o2 // false，这是两个对象 原型函数的原型对象 在JavaScript中，我们创建一个函数A(就是声明一个函数), 那么浏览器就会在内存中创建一个对象B，而且每个函数都默认会有一个属性 prototype 指向这个对象( 即：prototype的属性的值是这个对象 )。 这个对象B就是函数A的原型对象，简称函数的原型。 这个原型对象B 默认会有一个属性 constructor 指向了这个函数A ( 意思就是说：constructor属性的值是函数A )。 使用构造函数创建对象 当把一个函数作为构造函数 (理论上任何函数都可以作为构造函数) 使用new创建对象的时候，那么这个对象就会存在一个默认的不可见的属性，来指向构造函数的原型对象。 这个隐藏的属性在浏览器中用&#95;&#95;proto&#95;&#95;来表示。 举例： &#95;&#95;proto&#95;&#95; 和 prototype 的区别 &#95;&#95;proto&#95;&#95; 和 prototype 只是两个 key 而已 我们一般研究对象的 &#95;&#95;proto&#95;&#95; 和函数的 prototype 对象.__proto__ === 某函数.prototype // true 如果把函数看成对象，那么函数.__proto__ === Function.prototype 如果把 Function 看成对象，那么 Function.__proto__ === Function.prototype 重要公式123456789101112131415var 对象 = new 函数()对象.__proto__ === 对象的构造函数.prototype// 推论var number = new Number()number.__proto__ = Number.prototypeNumber.__proto__ = Function.prototype // 因为 Number 是 Function 的实例var object = new Object()object.__proto__ = Object.prototypeObject.__proto__ = Function.prototype // 因为 Object 是 Function 的实例var function = new Function()function.__proto__ = Function.prototypeFunction.__proto__ == Function.prototye // 因为 Function 是 Function 的实例！ 原型链通过&#95;&#95;proto&#95;&#95;形成原型链而非protrotype12function fn()&#123;&#125;;var test = new fn(); 把这个由&#95;&#95;proto&#95;&#95;串起来的直到Object.prototype.&#95;&#95;proto&#95;&#95;为null的链叫做原型链。 总结记住这三句话 第一句话：prototype是函数的原型对象，即prototype是一个对象，它会被对应的__proto__引用。 第二句话：要知道自己的__proto__引用了哪个prototype，只需要看看是哪个构造函数构造了你，那你的__proto__就是那个构造函数的 prototype。 第三句话：所有的构造函数的原型链最后都会引用 Object构造函数的原型，即可以理解 Object构造函数的原型是所有原型链的最底层，即 Object.prototype.__proto===null 一图流： 参考博客：https://www.jianshu.com/p/7119f0ab67c0]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS类型转换和内存机制]]></title>
    <url>%2F2018%2F09%2F22%2FJS%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[数据类型转换任意类型转字符串 String(x) x.toString() x + &#39;&#39; 加上空字符串 任意类型转数字 Number(x) 1Number('1') // 1 parseInt(x, 10) 后面的数字表示几进制 12345parseInt('1',10) // 1parseInt('011') // 11parseInt('011',8) // 9parseInt('s') // NaNparseInt('1s') // 1 parseFloat(x) 1parseFloat('1.23') // 1.23 x - 0 1'1' - 0 // 1 + x 12+ '1' // 1+ '-1' // -1 加号表示取它原本的值 任意类型转布尔 Boolean(x) !!x 12!! 0 false !! 1 true 五个falsy值：0, NaN, 空字符串, Null, undefined 所有的对象都是true 内存机制Chrome 给每个网页分配一定数量的内存这些内存要分给页面渲染器、网络模块、浏览器外壳和 JS 引擎（V8引擎）JS 引擎将内存分为代码区和数据区我们只研究数据区数据区分为 Stack（栈内存） 和 Heap（堆内存） 简单类型的数据直接存在 Stack 里 复杂类型的数据是把 Heap 地址存在 Stack 里 遇到问题就画图分析。 12345var a = 1var b = ab = 2请问 a 显示是几？1 12345var a = &#123;name: 'a'&#125;var b = ab = &#123;name: 'b'&#125;请问现在 a.name 是多少？'a' 12345var a = &#123;name: 'a'&#125;var b = ab.name = 'b'请问现在 a.name 是多少？'b' 12345var a = &#123;name: 'a'&#125;var b = ab = null请问现在 a 是什么？&#123;name: 'a'&#125; 垃圾回收 如果一个对象没有被引用，它就是垃圾，将被回收。 垃圾回收和数据结构有关系，即判断一个树的根有没有被引用 IE6有bug：关闭页面不会垃圾回收，除非关掉整个浏览器解决方法: 123window.onunload = function()&#123; document.div.onclick = null // 把每个监听事件都null掉，否则会造成内存泄漏&#125; 深复制和浅复制也可称为深拷贝和浅拷贝 12345var a = 1var b = ab = 2 //这个时候改变 ba 完全不受 b 的影响那么我们就说这是一个深复制 对于简单类型的数据来说，赋值就是深拷贝。对于复杂类型的数据（对象）来说，才要区分浅拷贝和深拷贝。 这是一个浅拷贝的例子1234var a = &#123;name: 'Allen'&#125;var b = ab.name = 'b'a.name === 'b' // true 因为我们对 b 操作后，a 也变了 什么是深拷贝？就是对 Heap 内存进行完全的拷贝。1234var a = &#123;name: 'Allen'&#125;var b = deepClone(a) // deepClone 还不知道怎么实现b.name = 'b'a.name === 'a' // true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS里的数据类型]]></title>
    <url>%2F2018%2F09%2F21%2FJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型JS一共有7中数据类型，其中分为两类：基本类型 和 引用类型。 概述 基本类型： number string boolean undefined null symbol 引用类型： object (array和function都属于object类型) typeof 运算符typeof运算符可以返回一个值的数据类型，用来确定一个值到底是什么类型。。1234567typeof 123 // "number"typeof '123' // "string"typeof false // "boolean"通过这个运算符可以发现两个bugtypeof null //objecttypeof Function //function number 数值表示数字类型 整数和小数：1 1.1 .1 科学记数法：1.23e2 二进制：var n = ob11 // 3 八进制：var n = 011 // 9 十六进制：var n = 0x11 // 17 string 字符串表示字符串类型1var s = 'hello' 可以使用””表示空字符串12var s = ""// "" 如何输入多行字符串123var s = '12345 \67890' // "12345 67890" 含回车符号 也可以使用+来连接123var s = 'hello' + 'world!'// "helloworld!" 无回车符号 转义符： \123var s = '123\n456' // \n换行// 123// 456 ES6语法：123var s = `1234567890` //length包含回车s.length //11 boolean 布尔值boolean只有两个值：true和false，通常用于条件判断 下列运算符会返回布尔值：前置逻辑运算符： ! (Not)相等运算符：===，!==，==，!=比较运算符：&gt;，&gt;=，&lt;，&lt;= 逻辑判断&amp;&amp;与||&amp;&amp;表示逻辑与，例如 a &amp;&amp; b表示a和b。常用来做逻辑判断123true &amp;&amp; true // truetrue &amp;&amp; false // falsefalse &amp;&amp; false // false ||表示逻辑或，比例a || b表示a或b。123true || true // truetrue || false // truefalse || false // false null和undefinednull和undefined都表示空值，但是为什么在JS里会有两个表示空的值呢？可以理解为这个JS之父设计的一个bug，具体差异如下： 声明一个变量但没赋值，默认为undefined 12var aa // undefined 声明一个对象但此时不想赋值，则赋值为null 12var a = nulla // null 声明一个变量但没想好给什么值，使用undefined 1var a = undefined 后面两点算是惯例。 object 对象object（对象），是一组key-value（键值对）的集合，也可看作是哈希表，是一种无序的复合数据集合。在命名key时，如果不加引号，则需要遵守命名规则，加上引号可以随意命名。12345678var obj = &#123; name: 'Allen', age: 23, gender: 'male',&#125;obj.name // 'Allen'obj.age // 20obj.gender // 'male' 读取对象中的属性有两种方式：1234567obj.name //'Allen'obj['name'] //'Allen'这两种方式是正确的，使用方括号运算符时参数必须是字符串，否则obj[name] //undefined，这里的参数其实是变量namevar name = 'age'obj[name] // 23 所以在访问对象本身的属性时不要使用这种方式，容易造成混乱。 当key是数字时：12345678910var obj = &#123; 1: 'Allen', 2: 23, 3: 'male'&#125;此时再使用obj.1是无法访问到属性的值的obj.1 // 报错obj[1] // 'Allen'obj['1'] // 'Allen'数字1会自动被转换为字符串'1' 对象当中还可以添加对象，key也可以是空字符串123456789101112131415var parent = &#123; name: 'Chris', age: 35, gender: 'male', '': '我的key是空字符串', child: &#123; name: 'Alice', age: '5', gender: 'female' &#125;&#125;parent.child.name // 'Alice'parent.child.age // 5parent.child.gender // 'female'parent[''] // '我的key是空字符串' delete和indelete命令用于删除对象的属性，删除成功后返回true。in运算符用于检查对象是否包含某个属性，如果包含就返回true，否则返回false。12345678910var obj = &#123; name: 'Allen', age: 23, gender: 'male'&#125;delete obj.name // trueobj //&#123;age: 23, gender: "male"&#125;'name' in obj // false'age' in obj // true 但in运算符不能识别哪些属性是对象自身的，哪些是继承的。1234var obj = &#123; p: 1&#125;'toString' in obj //true 上面代码中toString是继承而来而不是自身的。这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。1234var obj = &#123;&#125;;if ('toString' in obj) &#123; console.log(obj.hasOwnProperty('toString')) // false&#125; for…in 循环for…in循环用来遍历一个对象的全部属性。12345678910var obj = &#123; name: 'Allen', age: 23, gender: 'male'&#125;for(var key in obj)&#123; console.log(key) // name age gender console.log(obj[key]) // 'Allen' 23 'male'&#125;打印出的值的排列顺序并不一定，因为对象本身是无序的复合数据集合。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的一些技巧和知识]]></title>
    <url>%2F2018%2F09%2F14%2FCSS%2F</url>
    <content type="text"><![CDATA[CCS布局技巧1. 左右布局如果有以下html结构，设置左右两栏布局 &lt;div class="parent clearfix"&gt; &lt;div class="leftChild"&gt;&lt;/div&gt; &lt;div class="rightChild"&gt;&lt;/div&gt; &lt;/div&gt; 设置浮动左右布局常用的方法就是为子元素设置浮动，然后在其父元素上使用clearfix类清除浮动。示例代码如下： .clearfix::after{ content:""; display:block; clear:both; } .leftChild, .rightChild{ float:left; } 设置position绝对定位为父元素设置position:relative; 为子元素设置position:absolute 。示例代码如下： .parent{ position:relative; } .leftChild{ position:absolute; left:0; top:0; } .rightChild{ position:absolute; left:50%; top:0; } 2. 左中右布局左中右布局主要方法也是浮动或者绝对定位，不过可以分情况选择其一使用甚至结合使用。 3. 水平居中内联元素（比如文本和链接）在块级父容器中让内联元素水平居中，只需设置 text-align: center; 块级元素让单个块级元素水平居中的方法：先设置块级元素的 width，赋予一个宽度；然后设置块级元素的 margin: 0 auto; 多个块级元素如果要让多个块级元素在同一水平线上居中，那么可以修改它们的 display: inline-block; 或者父级容器的 display: flex; &lt;main class="inline-block-horizon-center"&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;/main&gt; &lt;main class="flex-horizon-center"&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;/main&gt; main div { max-width: 125px; } .inline-block-horizon-center { text-align: center; } .inline-block-horizon-center div { display: inline-block; vertical-align: middle/top; } .flex-horizon-center { display: flex; justify-content: center; } 如果想让多个块级元素垂直堆栈的水平对齐，依然可以通过设置 margin: 0 auto; main div { margin: 0 auto; } main div:nth-child(1) { width: 200px; } main div:nth-child(2) { width: 400px; } main div:nth-child(3) { width: 125px; } 4. 垂直居中内联元素单行 方法1：设置内联元素的块级父容器的 height 和 line-height 值相等 方法2：对于单行的内联元素，也可以添加等值的 padding-top 和 padding-bottom 实现垂直居中 多行 方法1：对于多行的内联元素，也可以添加等值的 padding-top 和 padding-bottom 实现垂直居中 方法2：使用 flexbox 实现垂直居中，因为对于父级容器为 display: flex 的元素来说，它的每一个子元素都是垂直居中的 块级元素已知高度先让元素 绝对定位 到父容器的中心点，然后设置 负向margin，负值的大小为其自身高度的一半 NOTE: 如果父元素设置了padding，则计算 负向margin 时，负值的大小为：其自身高度的一半再加上父元素的内边距 main { position: relative; } main div { position: absolute; top: 50%; height: 100px; margin-top: -50px; } 未知高度如果我们不知道块级元素的高度，那么就需要先将元素定位到容器的 中心位置，然后使用 transform 的 translate 属性，将元素的中心和父容器的 中心重合，从而实现垂直居中 main { position: relative; } main div { position: absolute; top: 50%; transform: translateY(-50%); } 使用flexbox高度不定则 div { display: flex; flex-direction: column; justify-content: center; } 宽高固定则 div { display: flex; justify-content: center; align-items: center; } 更多相关可参考: CSS居中指南https://www.w3ctech.com/topic/1515 position属性 position的含义是指定位类型，取值类型可以有：static、relative、absolute、fixed、inherit和sticky。 position: static static(没有定位)是position的默认值，元素处于正常的文档流中，会忽略left、top、right、bottom和z-index属性。 position: relative relative(相对定位)是指给元素设置相对于原本位置的定位，元素并不脱离文档流，因此元素原本的位置会被保留，其他的元素位置不会受到影响。 position: absolute absolute(绝对定位)是指给元素设置绝对的定位，相对定位的对象可以分为两种情况： 1) 设置了absolute的元素如果存在有祖先元素设置了position属性为relative或者absolute，则这时元素的定位对象为此已设置position属性的祖先元素。 2) 如果并没有设置了position属性的祖先元素，则此时相对于body进行定位。 position: fixed 可以简单说fixed是特殊版的absolute，fixed元素总是相对于浏览器窗体定位的。 inherit 继承父元素的position属性，但需要注意的是IE8以及往前的版本都不支持inherit属性。 sticky 在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果。 更多相关可参考网站: http://www.cnblogs.com/s1nker/p/4835079.html CSS其他技巧和知识引用CSS的四种方式 内联style属性 style标签 引用外部css文件 link标签 @import url(./style.css); 清除float导致浮动的方法 在float元素的父级元素上加上clearfix的class，示例见第一部分左右布局， 元素的高度是由什么决定的？ 元素的高度，由其内部文档流元素的高度总和决定 文档流: 文档内元素的流动方向 尽量不写高度宽度，用padding和line-height解决，否则可能造成bug 字体较小的时候，可用line-height控制内联元素的高度 中文会自动换行而英文不会word-break: break-all; 使得一串英文会被打断 分开 word-break: break-word; 使得不会打断 分开 用CSS画三角形的方法.triangle{ border: 10px solid transparent; width: 0px; border-left-color: #E6686A; border-top-width: 0px; } 伪元素::before和::after相当于div 加上这两行的代码才会显示内容content: “”;display: block;（如果是position:absolute就不用加，因为绝对定位后元素会默认display:block;） 让导航栏在同一行里均匀分布给ul加css ul{ display:flex; justyfy-content:space-between; } 去掉li的float:left去掉ul的clearfix icon图标素材资源的网站 http://www.iconfont.cn阿里巴巴的矢量图标管理、交流平台。 其他CSS相关的补充 用到display:inline-block 一般要再加vertical-align:top 背景图铺满整个背景 background-size:cover box-sizing: border-box; 告诉浏览器去理解你设置的边框和内边距的值是包含在width内的 linear-gradient 渐变色 尽量不写高度宽度 用padding和line-height解决]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML的常用标签和一些重要知识点]]></title>
    <url>%2F2018%2F09%2F13%2FHTML-intro%2F</url>
    <content type="text"><![CDATA[HTML标签的一些知识点a 标签 超链接 跳转页面（HTTP GET 请求） 属性见 MDN： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a href：指定链接地址 target：规定“href”属性中指定的网页或文件以何种方式行进跳转或打开，其值包括：_blank、_self、_parent、_top以及iframe的name属性的值 特别的使用方法 锚点 1&lt;a href="#top"&gt;link&lt;/a&gt; 只有锚点不发送get请求。&quot;#top&quot;即点击回到页面顶部。 下载 1&lt;a href="https://qq.com" download&gt;下 载&lt;/a&gt; 1. 加上“download”属性，可下载文件:下载.html。 若不加https:或http: 会变成file协议。 2. 那么如果不加download能下载吗？ 若目标http响应写了Content-type: application/octet-stream 浏览器也会以下载的形式接受请求。 若Content-type: text/html 则不会。 伪协议 12&lt;a href="javascript:;"&gt;link&lt;/a&gt; 满足需求:点击但不进行任何操作。&lt;a href="javascript:alert(1)"&gt;link&lt;/a&gt; 点击运行此JS。 查询请求 1&lt;a href="?name=xxx"&gt;link&lt;/a&gt; 自动把?name=xxx加进地址栏，发起get请求。 文件路径 1&lt;a href="xxx.html" download&gt;QQ&lt;/a&gt; 相对路径，点击可打开同目录下的xxx.html form 标签 表单 跳转页面（HTTP POST 请求） 属性见 MDN： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form 12345&lt;form action="users" method="post"&gt; &lt;input type="text" name="username"&gt; &lt;input type="password" name="password"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 使用注意事项 如果form里没提交按钮就不能提交。 向users路径发送post请求。 若输入xxx和yyy并提交，发送post请求的第四部分数据为username=xxx&amp;password=yyy若输入的是中文并提交，发送post请求的数据 xxx和yyy 会转义为utf-8字符。 name 必须 要写，不写的话提交的时候不会带上你的数据。 input / button 输入 / 按钮 区别：是否为「空标签」 input 的属性见： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input button 的属性见： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button 使用注意事项 如果一个form里只有一个按钮 1234&lt;button&gt;提交&lt;/button&gt; 则浏览器会默认为type = "submit"，是一个普通的按钮&lt;button type= "button" &gt;提交&lt;/button&gt; 不会提交，是一个普通的按钮&lt;input type= "submit" value="提交"&gt; 是一个提交按钮&lt;input value="提交"&gt; 不会提交，是一个普通的按钮 实现点击文字勾上复选框 1&lt;input type=”checkbox” id=”XXX”&gt;&lt;label for=”XXX”&gt;你好&lt;/label&gt; 点击&quot;你好&quot;，复选框也一起勾选了 123&lt;label&gt;用户名&lt;input type=”text” name=”username”&gt;&lt;/label&gt; &lt;label&gt;密码&lt;input type=”password” name=”password”&gt;&lt;/label&gt; &lt;label&gt;&lt;input type=”checkbox” name=”agree”&gt;同意&lt;/label&gt; 用label把input包住，也能实现点击文字勾上复选框。 name一定要写的一样，才能复选 / 单选，并在发送请求时提交到服务器。 1234&lt;label&gt;&lt;input type=”checkBox” name=”fruit” value="yes"&gt;香蕉&lt;/label&gt;&lt;label&gt;&lt;input type=”checkBox” name=”fruit” value="no"&gt;橘子&lt;/label&gt; &lt;label&gt;&lt;input type=”radio” name=”YorN” value="yes"&gt;Yes&lt;/label&gt;&lt;label&gt;&lt;input type=”radio” name=”YorN” value="no"&gt;No&lt;/label&gt; table 标签 表格 用于展示数据 属性见： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table 相关概念thead：表头（表格标题及头部信息不等）tbody：表中（表格显示的内容部分）tfoot：表尾（表格说明与备注部分）tr：行th：单元格，作为行或列的标题呈现td：单元格，作为内容单元格呈现caption：表格主标题，位于表格之外 表格常用属性width/height：设置宽度/高度border：设置边框align：设置表格对齐方式（left/center/right）cellspacing：设置单元格与单元格之间的间距cellpadding：设置单元格与内容之间的间距bgcolor：设置表格背景颜色background：设置背景图片colspan：跨列 ‘’rowspan：跨行 ‘’ HTML其他常见标签文本标签 标题：h1~h6 文本：span 段落：p 强调：em 粗体：b 斜体：i 删除线：s 上标：sup 下标：sub 语义化标签 头部：header 尾部：footer 导航：nav 文章：article 章节：section 侧栏：aside 地址：address 时间：time 标记：mark 布局：div 引用：blockquote 文档主要内容：main （块级标签） 详细信息：details，一般与 summary 标签一起使用，summary 作为details的第一个子标签使用 格式化标签 换行：br 水平分割线：hr img 标签 图片 src：指定图片链接地址（必须） width/height：设置宽度/高度 title：设置图片标题，鼠标悬浮在图片上时显示 alt：设置提示，当图片加载失败时会显示 HTML 元素类别 块级元素（block） 行内元素（inline） 行内块元素（inline-block）。 display：blockblock元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素的宽度。block元素可以设置width、height属性。块级元素及时设置了宽度，仍然会独占一行。block元素可以设置margin、padding属性。 display：inlineinline元素不会独占一行，多个相邻的行内元素会排在同一行里，直到一行排列不下，才会新换行，其宽度随元素的内容而变化。inline元素设置width、height属性无效。inline元素的margin和padding属性，水平方向的padding-left、padding-right、margin-left、margin-right都产生边距效果，但竖直方向的padidng-top、padding-bottom、margin-top以及margin-bottom不会产生边距效果。 display：inline-block简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其具有block的宽度高度特性又具有inline的同行特性。 补充和总结 a标签的一些特别用法，见上文。 input和button的一些使用注意，见上文。 表单提交时，发送请求会带有表单中的数据，name属性必须写，具体见上文form部分。 Contenteditable属性可使元素内容可编辑。 colgroup标签可调整表格各栏的宽度，很方便。 参考博客 https://blog.csdn.net/hierarch_lee/article/details/54236380]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的请求与响应]]></title>
    <url>%2F2018%2F09%2F11%2FHTTP-intro%2F</url>
    <content type="text"><![CDATA[Server + Client + HTTP* 浏览器负责发起请求 * 服务器在 80 端口接收请求 * 服务器负责返回内容（响应） * 浏览器负责下载响应内容 HTTP 的作用就是指导浏览器和服务器如何进行沟通。 请求请求示例输入以下命令： curl -s -v -H "Allen: xxx" -- "https://www.baidu.com" 请求的内容为： GET / HTTP/1.1 Host: www.baidu.com User-Agent: curl/7.54.0 Accept: */* Allen: xxx 请求的格式1 动词 路径 协议/版本 2 Key1: value1 2 Key2: value2 2 Key3: value3 2 Content-Type: application/x-www-form-urlencoded 2 Host: www.baidu.com 2 User-Agent: curl/7.54.0 3 4 要上传的数据 1. 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 2. 第三部分永远都是一个回车（\n） 3. 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等 4. 这里的路径包括「查询参数」，但不包括「锚点」 5. 如果你没有写路径，那么路径默认为 / 6. 第 2 部分中的 Content-Type 标注了第 4 部分的格式 如何用 Chrome 查看响应1. 打开 Network 2. 地址栏输入网址 3. 在 Network 点击，查看 request，点击「view source」 4. 点击「view source」后可以看到请求的前三部分 5. 如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到 响应请求示例对应上面请求的响应如下： HTTP/1.1 200 OK Accept-Ranges: bytes Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Connection: Keep-Alive Content-Length: 2443 Content-Type: text/html Date: Tue, 10 Oct 2017 09:14:05 GMT Etag: "5886041d-98b" Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT Pragma: no-cache Server: bfe/1.0.8.18 Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/ &lt;!DOCTYPE html&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略…… 响应的格式1 协议/版本号 状态码 状态解释 2 Key1: value1 2 Key2: value2 2 Content-Length: 17931 2 Content-Type: text/html 3 4 要下载的内容 * 状态码大概记一下，是服务器对浏览器说的话 * 1xx 不常用 * 2xx 表示成功 * 3xx 表示滚吧 * 4xx 表示你丫错了 * 5xx 表示好吧，我错了 * 状态解释没什么用 * 第 2 部分中的 Content-Type 标注了第 4 部分的格式 * 第 2 部分中的 Content-Type 遵循 MIME 规范 如何用 Chrome 查看响应1. 打开 Network 2. 输入网址 3. 选中第一个响应 4. 查看 Response Headers，点击「view source」 5. 点击「view source」后你会看到响应的前两部分 6. 查看 Response 或者 Preview，你会看到响应的第 4 部分 Chrome开发者工具查看 HTTP 请求与响应可详见：https://www.jianshu.com/p/a08134dbee23 如何使用 curl 命令？在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 语法：# curl [option] [url] 常见参数：-A/--user-agent &lt;string&gt; 设置用户代理发送给服务器 -b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置 -c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中 -C/--continue-at &lt;offset&gt; 断点续转 -D/--dump-header &lt;file&gt; 把header信息写入到该文件中 -e/--referer 来源网址 -f/--fail 连接失败时不显示http错误 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -r/--range &lt;range&gt; 检索来自HTTP/1.1或FTP服务器字节范围 -s/--silent 静音模式。不输出任何东西 -T/--upload-file &lt;file&gt; 上传文件 -u/--user &lt;user[:password]&gt; 设置服务器的用户和密码 -w/--write-out [format] 什么输出完成后 -x/--proxy &lt;host[:port]&gt; 在给定的端口上使用HTTP代理 -#/--progress-bar 进度条显示当前的传送状态 curl命令的更多用法可详见：http://man.linuxde.net/curl]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo博客（Next主题）过程中碰到的问题]]></title>
    <url>%2F2018%2F09%2F11%2FHexo%2F</url>
    <content type="text"><![CDATA[该主题的github主页：https://github.com/iissnan/hexo-theme-next 侧边菜单修改却无法访问在next的_config.yml文件中修改menu配置，添加tag和categories选项，但点击会出现404页面。 解决办法：在根目录执行以下命令：12hexo new page "tags" hexo new page "categories" 打开它们并相应添加type: “tags”和type: “categories”，保存 安装搜索功能 Local Search在next的_config.yml文件中修改Local Search的enable: true后，搜索功能仍无效 解决办法：安装 hexo-generator-search和 hexo-generator-searchdb 在根目录下执行以下命令：12$ npm install hexo-generator-search --save$ npm install hexo-generator-searchdb --save 在根目录的_config.yml文件中添加12345search: path: search.xml field: post format: html limit: 10000]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git入门]]></title>
    <url>%2F2018%2F09%2F10%2Fgit%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[git版本控制中几个重要概念1234561.git init 初始化本地仓库 .git2.git add 文件路径，用来将变动加到暂存区3.git commit -v 提交时显示所有diff信息 使用git前配置12345git config --global user.name 你的英文名git config --global user.email 你的邮箱git config --global push.default matchinggit config --global core.quotepath falsegit config --global core.editor "vim" 下面的命令可获得该终端的ssh key1cat ~/.ssh/id_rsa.pub 常用命令123456789101112git init //不要在已经初始化好的仓库使用，否则会将已经初始化完成的仓库覆盖git status //查看状态git add //提交文件放入暂存区git commit //将暂存区的更新提交到本地仓库git push origin master //把当前本地仓库里的改动推送到远程仓库（origin）的master分支。之后可以直接git push。git pull //当远程仓库有变动但是本地仓库没有更新，会拒绝git push， 使用git pull将远程仓库拉到本地仓库，合并变动。git push -f origin master //强制推送，会覆盖别人的代码git remote add xxx git@xxx.git //再次添加一个远程仓库的标签git push xxx master //推送到xxx标签的地址git remote remove xxx //删除xxx标签git remote set-url origin url //修改origin标签对应的地址git remote rename xxx coding //把xxx标签名修改为coding 实例打开 git bash，进入某目录后输入以下命令：12345cd blog -- 进入blog文件夹git init -- 初始化本地仓库，创建.git目录touch index.html -- 添加index.html文件git add index.html -- 将文件添加到暂存区 (也可以使用git add . 表示将当前目录内所有改动都加入暂存区)git commit index.html -m '添加index.html' 告诉 git，这些文件我要加到仓库里(也可以一次性git commit -m "添加所有改动文件")]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git几个常用命令和一个命令查询工具]]></title>
    <url>%2F2018%2F09%2F10%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[几个常用命令的使用方法ls 罗列* ls 路径 显示所有文件 * ls -a 路径 显示所有目录和文件（文件或目录名称为“.”的视为隐藏，不会列出）； * ls -l 路径 以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等； * ls -al 路径 在ls -l的基础上多显示以“.“开头的隐藏文件； cat 显示文件内容* cat m1 在屏幕上显示文件ml的内容 * cat m1 m2 同时显示文件ml和m2的内容 * cat m1 m2 &gt; file 将文件ml和m2合并后放入文件file中 mv 移动 / 重命名* mv 源路径 目标路径 将某文件从源路径移动至目标路径 * mv 1.txt 2.txt 把 1.txt 移到 2.txt ，也就是重命名 touch 触摸* touch 1.txt 创建1.txt文件 或 改变该文件的更新时间 explainshell.com 的使用 想知道某个命令的用法，搜索该命令就能展示其所有的用法。 在输入框内输入一段命令，这个网站就能帮助你解析该命令是如何工作的，简洁易懂。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
