<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[模仿jQuery实现一个API]]></title>
    <url>%2F2018%2F09%2F29%2FaboutjQuery%2F</url>
    <content type="text"><![CDATA[如何模仿jQuery实现一个API？jQuery是一个 JavaScript 库，核心理念是 - write less, do more，大大方便了我们的编程。 那么关于下面的代码，如何实现类似jQuery提供的api呢？123456window.jQuery = ???window.$ = jQueryvar $div = $('div')$div.addClass('red') // 可将所有 div 的 class 添加一个 red$div.setText('hi') // 可将所有 div 的 textContent 变为 hi 首先把选择器写出来 123456789101112131415161718window.jQuery = function(nodeOrSelector)&#123; let nodes = &#123;&#125; //初始化对象 //判断用户想获取一个还是多个元素节点 if(typeof nodeOrSelector === 'string')&#123; let temp = document.querySelectorAll(nodeOrSelector) // 伪数组 //遍历临时对象temp，将它的值放入nodes内，得到一个纯净的伪数组，原型链指向Object for(let i=0;i&lt;temp.length;i++)&#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125; else if(nodeOrSelector instanceof Node)&#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; return nodes //返回nodes&#125; 添加addClass方法 123456nodes.addClass = function(classes)&#123; //遍历nodes，为nodes内每一个元素节点添加class for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].classList.add(classes) &#125;&#125; 添加setText方法 123456nodes.setText = function(text)&#123; //遍历nodes，为nodes内每一个元素节点的textContent添加text for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].textContent = text &#125;&#125; 完整代码 123456789101112131415161718192021222324252627282930313233343536window.jQuery = function(nodeOrSelector)&#123; let nodes = &#123;&#125; if(typeof nodeOrSelector === 'string')&#123; let temp = document.querySelectorAll(nodeOrSelector) for(let i=0;i&lt;temp.length;i++)&#123; nodes[i] = temp[i] &#125; nodes.length = temp.length &#125; else if(nodeOrSelector instanceof Node)&#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; nodes.addClass = function(classes)&#123; //遍历nodes，为nodes内每一个元素节点添加class for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].classList.add(classes) &#125; &#125; nodes.setText = function(text)&#123; //遍历nodes，为nodes内每一个元素节点的textContent添加text for(let i=0;i&lt;nodes.length;i++)&#123; nodes[i].textContent = text &#125; &#125; return nodes&#125;window.$ = jQueryvar $div = $('div')$div.addClass('red') // 可将所有 div 的 class 添加一个 red$div.setText('hi') // 可将所有 div 的 textContent 变为 hi 完成，另外以上代码还使用到了JS的闭包。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型与原型链]]></title>
    <url>%2F2018%2F09%2F24%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[全局函数 Number12var n1 = 1var n2 = new Number(1) // 创建一个 Number 对象 两者的区别是什么？前者将数据直接存在 Stack 里，后者实际上是一个哈希对象，把 Heap 地址存在 Stack 里。 但是前者没有toString()属性，为什么n1.toString()的结果是&#39;1&#39;？JS引擎会建立一个临时的对象， 12temp = new Number(n1)temp.toString() 然后再把temp回收掉，所以几乎没人用第二种写法。 String 12var s1 = 'hello'var s2 = new String('hello') // 创建一个 String 对象 和Number同理。 Boolean 12var b1 = truevar b2 = new Boolean(true) // 创建一个 Boolean 对象 和Number同理。 Object 12var o1 = &#123;&#125;var o2 = new Object() o1 和 o2 没区别，不过ol === o2 // false，这是两个对象 原型函数的原型对象 在JavaScript中，我们创建一个函数A(就是声明一个函数), 那么浏览器就会在内存中创建一个对象B，而且每个函数都默认会有一个属性 prototype 指向这个对象( 即：prototype的属性的值是这个对象 )。 这个对象B就是函数A的原型对象，简称函数的原型。 这个原型对象B 默认会有一个属性 constructor 指向了这个函数A ( 意思就是说：constructor属性的值是函数A )。 使用构造函数创建对象 当把一个函数作为构造函数 (理论上任何函数都可以作为构造函数) 使用new创建对象的时候，那么这个对象就会存在一个默认的不可见的属性，来指向构造函数的原型对象。 这个隐藏的属性在浏览器中用&#95;&#95;proto&#95;&#95;来表示。 举例： &#95;&#95;proto&#95;&#95; 和 prototype 的区别 &#95;&#95;proto&#95;&#95; 和 prototype 只是两个 key 而已 我们一般研究对象的 &#95;&#95;proto&#95;&#95; 和函数的 prototype 对象.__proto__ === 某函数.prototype // true 如果把函数看成对象，那么函数.__proto__ === Function.prototype 如果把 Function 看成对象，那么 Function.__proto__ === Function.prototype 重要公式123456789101112131415var 对象 = new 函数()对象.__proto__ === 对象的构造函数.prototype// 推论var number = new Number()number.__proto__ = Number.prototypeNumber.__proto__ = Function.prototype // 因为 Number 是 Function 的实例var object = new Object()object.__proto__ = Object.prototypeObject.__proto__ = Function.prototype // 因为 Object 是 Function 的实例var function = new Function()function.__proto__ = Function.prototypeFunction.__proto__ == Function.prototye // 因为 Function 是 Function 的实例！ 原型链通过&#95;&#95;proto&#95;&#95;形成原型链而非protrotype12function fn()&#123;&#125;;var test = new fn(); 把这个由&#95;&#95;proto&#95;&#95;串起来的直到Object.prototype.&#95;&#95;proto&#95;&#95;为null的链叫做原型链。 总结 查找属性，如果本身没有，则会去&#95;&#95;proto&#95;&#95;中查找，也就是构造函数的原型中查找，如果构造函数中也没有该属性，因为构造函数也是对象，也有&#95;&#95;proto&#95;&#95;，那么会去它的原型中查找，一直到null，如果没有则返回undefined 一图流： 一些参考的博客：https://blog.csdn.net/u012468376/article/details/53121081https://blog.csdn.net/yucihent/article/details/79424506]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS类型转换和内存机制]]></title>
    <url>%2F2018%2F09%2F22%2FJS%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%92%8C%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[数据类型转换任意类型转字符串 String(x) x.toString() x + &#39;&#39; 加上空字符串 任意类型转数字 Number(x) 1Number('1') // 1 parseInt(x, 10) 后面的数字表示几进制 12345parseInt('1',10) // 1parseInt('011') // 11parseInt('011',8) // 9parseInt('s') // NaNparseInt('1s') // 1 parseFloat(x) 1parseFloat('1.23') // 1.23 x - 0 1'1' - 0 // 1 + x 12+ '1' // 1+ '-1' // -1 加号表示取它原本的值 任意类型转布尔 Boolean(x) !!x 12!! 0 false !! 1 true 五个falsy值：0, NaN, 空字符串, Null, undefined 所有的对象都是true 内存机制Chrome 给每个网页分配一定数量的内存这些内存要分给页面渲染器、网络模块、浏览器外壳和 JS 引擎（V8引擎）JS 引擎将内存分为代码区和数据区我们只研究数据区数据区分为 Stack（栈内存） 和 Heap（堆内存） 简单类型的数据直接存在 Stack 里 复杂类型的数据是把 Heap 地址存在 Stack 里 遇到问题就画图分析。 12345var a = 1var b = ab = 2请问 a 显示是几？1 12345var a = &#123;name: 'a'&#125;var b = ab = &#123;name: 'b'&#125;请问现在 a.name 是多少？'a' 12345var a = &#123;name: 'a'&#125;var b = ab.name = 'b'请问现在 a.name 是多少？'b' 12345var a = &#123;name: 'a'&#125;var b = ab = null请问现在 a 是什么？&#123;name: 'a'&#125; 垃圾回收 如果一个对象没有被引用，它就是垃圾，将被回收。 垃圾回收和数据结构有关系，即判断一个树的根有没有被引用 IE6有bug：关闭页面不会垃圾回收，除非关掉整个浏览器解决方法: 123window.onunload = function()&#123; document.div.onclick = null // 把每个监听事件都null掉，否则会造成内存泄漏&#125; 深复制和浅复制也可称为深拷贝和浅拷贝 12345var a = 1var b = ab = 2 //这个时候改变 ba 完全不受 b 的影响那么我们就说这是一个深复制 对于简单类型的数据来说，赋值就是深拷贝。对于复杂类型的数据（对象）来说，才要区分浅拷贝和深拷贝。 这是一个浅拷贝的例子1234var a = &#123;name: 'Allen'&#125;var b = ab.name = 'b'a.name === 'b' // true 因为我们对 b 操作后，a 也变了 什么是深拷贝？就是对 Heap 内存进行完全的拷贝。1234var a = &#123;name: 'Allen'&#125;var b = deepClone(a) // deepClone 还不知道怎么实现b.name = 'b'a.name === 'a' // true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS里的数据类型]]></title>
    <url>%2F2018%2F09%2F21%2FJS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型JS一共有7中数据类型，其中分为两类：基本类型 和 引用类型。 概述 基本类型： number string boolean undefined null symbol 引用类型： object (array和function都属于object类型) typeof 运算符typeof运算符可以返回一个值的数据类型，用来确定一个值到底是什么类型。。1234567typeof 123 // "number"typeof '123' // "string"typeof false // "boolean"通过这个运算符可以发现两个bugtypeof null //objecttypeof Function //function number 数值表示数字类型 整数和小数：1 1.1 .1 科学记数法：1.23e2 二进制：var n = ob11 // 3 八进制：var n = 011 // 9 十六进制：var n = 0x11 // 17 string 字符串表示字符串类型1var s = 'hello' 可以使用””表示空字符串12var s = ""// "" 如何输入多行字符串123var s = '12345 \67890' // "12345 67890" 含回车符号 也可以使用+来连接123var s = 'hello' + 'world!'// "helloworld!" 无回车符号 转义符： \123var s = '123\n456' // \n换行// 123// 456 ES6语法：123var s = `1234567890` //length包含回车s.length //11 boolean 布尔值boolean只有两个值：true和false，通常用于条件判断 下列运算符会返回布尔值：前置逻辑运算符： ! (Not)相等运算符：===，!==，==，!=比较运算符：&gt;，&gt;=，&lt;，&lt;= 逻辑判断&amp;&amp;与||&amp;&amp;表示逻辑与，例如 a &amp;&amp; b表示a和b。常用来做逻辑判断123true &amp;&amp; true // truetrue &amp;&amp; false // falsefalse &amp;&amp; false // false ||表示逻辑或，比例a || b表示a或b。123true || true // truetrue || false // truefalse || false // false null和undefinednull和undefined都表示空值，但是为什么在JS里会有两个表示空的值呢？可以理解为这个JS之父设计的一个bug，具体差异如下： 声明一个变量但没赋值，默认为undefined 12var aa // undefined 声明一个对象但此时不想赋值，则赋值为null 12var a = nulla // null 声明一个变量但没想好给什么值，使用undefined 1var a = undefined 后面两点算是惯例。 object 对象object（对象），是一组key-value（键值对）的集合，也可看作是哈希表，是一种无序的复合数据集合。在命名key时，如果不加引号，则需要遵守命名规则，加上引号可以随意命名。12345678var obj = &#123; name: 'Allen', age: 23, gender: 'male',&#125;obj.name // 'Allen'obj.age // 20obj.gender // 'male' 读取对象中的属性有两种方式：1234567obj.name //'Allen'obj['name'] //'Allen'这两种方式是正确的，使用方括号运算符时参数必须是字符串，否则obj[name] //undefined，这里的参数其实是变量namevar name = 'age'obj[name] // 23 所以在访问对象本身的属性时不要使用这种方式，容易造成混乱。 当key是数字时：12345678910var obj = &#123; 1: 'Allen', 2: 23, 3: 'male'&#125;此时再使用obj.1是无法访问到属性的值的obj.1 // 报错obj[1] // 'Allen'obj['1'] // 'Allen'数字1会自动被转换为字符串'1' 对象当中还可以添加对象，key也可以是空字符串123456789101112131415var parent = &#123; name: 'Chris', age: 35, gender: 'male', '': '我的key是空字符串', child: &#123; name: 'Alice', age: '5', gender: 'female' &#125;&#125;parent.child.name // 'Alice'parent.child.age // 5parent.child.gender // 'female'parent[''] // '我的key是空字符串' delete和indelete命令用于删除对象的属性，删除成功后返回true。in运算符用于检查对象是否包含某个属性，如果包含就返回true，否则返回false。12345678910var obj = &#123; name: 'Allen', age: 23, gender: 'male'&#125;delete obj.name // trueobj //&#123;age: 23, gender: "male"&#125;'name' in obj // false'age' in obj // true 但in运算符不能识别哪些属性是对象自身的，哪些是继承的。1234var obj = &#123; p: 1&#125;'toString' in obj //true 上面代码中toString是继承而来而不是自身的。这时，可以使用对象的hasOwnProperty方法判断一下，是否为对象自身的属性。1234var obj = &#123;&#125;;if ('toString' in obj) &#123; console.log(obj.hasOwnProperty('toString')) // false&#125; for…in 循环for…in循环用来遍历一个对象的全部属性。12345678910var obj = &#123; name: 'Allen', age: 23, gender: 'male'&#125;for(var key in obj)&#123; console.log(key) // name age gender console.log(obj[key]) // 'Allen' 23 'male'&#125;打印出的值的排列顺序并不一定，因为对象本身是无序的复合数据集合。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS的一些技巧和知识]]></title>
    <url>%2F2018%2F09%2F14%2FCSS%2F</url>
    <content type="text"><![CDATA[CCS布局技巧1. 左右布局如果有以下html结构，设置左右两栏布局 &lt;div class="parent clearfix"&gt; &lt;div class="leftChild"&gt;&lt;/div&gt; &lt;div class="rightChild"&gt;&lt;/div&gt; &lt;/div&gt; 设置浮动左右布局常用的方法就是为子元素设置浮动，然后在其父元素上使用clearfix类清除浮动。示例代码如下： .clearfix::after{ content:""; display:block; clear:both; } .leftChild, .rightChild{ float:left; } 设置position绝对定位为父元素设置position:relative; 为子元素设置position:absolute 。示例代码如下： .parent{ position:relative; } .leftChild{ position:absolute; left:0; top:0; } .rightChild{ position:absolute; left:50%; top:0; } 2. 左中右布局左中右布局主要方法也是浮动或者绝对定位，不过可以分情况选择其一使用甚至结合使用。 3. 水平居中内联元素（比如文本和链接）在块级父容器中让内联元素水平居中，只需设置 text-align: center; 块级元素让单个块级元素水平居中的方法：先设置块级元素的 width，赋予一个宽度；然后设置块级元素的 margin: 0 auto; 多个块级元素如果要让多个块级元素在同一水平线上居中，那么可以修改它们的 display: inline-block; 或者父级容器的 display: flex; &lt;main class="inline-block-horizon-center"&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;/main&gt; &lt;main class="flex-horizon-center"&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;div&gt;I'm an element&lt;/div&gt; &lt;/main&gt; main div { max-width: 125px; } .inline-block-horizon-center { text-align: center; } .inline-block-horizon-center div { display: inline-block; vertical-align: middle/top; } .flex-horizon-center { display: flex; justify-content: center; } 如果想让多个块级元素垂直堆栈的水平对齐，依然可以通过设置 margin: 0 auto; main div { margin: 0 auto; } main div:nth-child(1) { width: 200px; } main div:nth-child(2) { width: 400px; } main div:nth-child(3) { width: 125px; } 4. 垂直居中内联元素单行 方法1：设置内联元素的块级父容器的 height 和 line-height 值相等 方法2：对于单行的内联元素，也可以添加等值的 padding-top 和 padding-bottom 实现垂直居中 多行 方法1：对于多行的内联元素，也可以添加等值的 padding-top 和 padding-bottom 实现垂直居中 方法2：使用 flexbox 实现垂直居中，因为对于父级容器为 display: flex 的元素来说，它的每一个子元素都是垂直居中的 块级元素已知高度先让元素 绝对定位 到父容器的中心点，然后设置 负向margin，负值的大小为其自身高度的一半 NOTE: 如果父元素设置了padding，则计算 负向margin 时，负值的大小为：其自身高度的一半再加上父元素的内边距 main { position: relative; } main div { position: absolute; top: 50%; height: 100px; margin-top: -50px; } 未知高度如果我们不知道块级元素的高度，那么就需要先将元素定位到容器的 中心位置，然后使用 transform 的 translate 属性，将元素的中心和父容器的 中心重合，从而实现垂直居中 main { position: relative; } main div { position: absolute; top: 50%; transform: translateY(-50%); } 使用flexbox高度不定则 div { display: flex; flex-direction: column; justify-content: center; } 宽高固定则 div { display: flex; justify-content: center; align-items: center; } 更多相关可参考: CSS居中指南https://www.w3ctech.com/topic/1515 position属性 position的含义是指定位类型，取值类型可以有：static、relative、absolute、fixed、inherit和sticky。 position: static static(没有定位)是position的默认值，元素处于正常的文档流中，会忽略left、top、right、bottom和z-index属性。 position: relative relative(相对定位)是指给元素设置相对于原本位置的定位，元素并不脱离文档流，因此元素原本的位置会被保留，其他的元素位置不会受到影响。 position: absolute absolute(绝对定位)是指给元素设置绝对的定位，相对定位的对象可以分为两种情况： 1) 设置了absolute的元素如果存在有祖先元素设置了position属性为relative或者absolute，则这时元素的定位对象为此已设置position属性的祖先元素。 2) 如果并没有设置了position属性的祖先元素，则此时相对于body进行定位。 position: fixed 可以简单说fixed是特殊版的absolute，fixed元素总是相对于浏览器窗体定位的。 inherit 继承父元素的position属性，但需要注意的是IE8以及往前的版本都不支持inherit属性。 sticky 在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果。 更多相关可参考网站: http://www.cnblogs.com/s1nker/p/4835079.html CSS其他技巧和知识引用CSS的四种方式 内联style属性 style标签 引用外部css文件 link标签 @import url(./style.css); 清除float导致浮动的方法 在float元素的父级元素上加上clearfix的class，示例见第一部分左右布局， 元素的高度是由什么决定的？ 元素的高度，由其内部文档流元素的高度总和决定 文档流: 文档内元素的流动方向 尽量不写高度宽度，用padding和line-height解决，否则可能造成bug 字体较小的时候，可用line-height控制内联元素的高度 中文会自动换行而英文不会word-break: break-all; 使得一串英文会被打断 分开 word-break: break-word; 使得不会打断 分开 用CSS画三角形的方法.triangle{ border: 10px solid transparent; width: 0px; border-left-color: #E6686A; border-top-width: 0px; } 伪元素::before和::after相当于div 加上这两行的代码才会显示内容content: “”;display: block;（如果是position:absolute就不用加，因为绝对定位后元素会默认display:block;） 让导航栏在同一行里均匀分布给ul加css ul{ display:flex; justyfy-content:space-between; } 去掉li的float:left去掉ul的clearfix icon图标素材资源的网站 http://www.iconfont.cn阿里巴巴的矢量图标管理、交流平台。 其他CSS相关的补充 用到display:inline-block 一般要再加vertical-align:top 背景图铺满整个背景 background-size:cover box-sizing: border-box; 告诉浏览器去理解你设置的边框和内边距的值是包含在width内的 linear-gradient 渐变色 尽量不写高度宽度 用padding和line-height解决]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML的常用标签和一些重要知识点]]></title>
    <url>%2F2018%2F09%2F13%2FHTML-intro%2F</url>
    <content type="text"><![CDATA[HTML标签的一些知识点a 标签 超链接 跳转页面（HTTP GET 请求） 属性见 MDN： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a href：指定链接地址 target：规定“href”属性中指定的网页或文件以何种方式行进跳转或打开，其值包括：_blank、_self、_parent、_top以及iframe的name属性的值 特别的使用方法 锚点 1&lt;a href="#top"&gt;link&lt;/a&gt; 只有锚点不发送get请求。&quot;#top&quot;即点击回到页面顶部。 下载 1&lt;a href="https://qq.com" download&gt;下 载&lt;/a&gt; 1. 加上“download”属性，可下载文件:下载.html。 若不加https:或http: 会变成file协议。 2. 那么如果不加download能下载吗？ 若目标http响应写了Content-type: application/octet-stream 浏览器也会以下载的形式接受请求。 若Content-type: text/html 则不会。 伪协议 12&lt;a href="javascript:;"&gt;link&lt;/a&gt; 满足需求:点击但不进行任何操作。&lt;a href="javascript:alert(1)"&gt;link&lt;/a&gt; 点击运行此JS。 查询请求 1&lt;a href="?name=xxx"&gt;link&lt;/a&gt; 自动把?name=xxx加进地址栏，发起get请求。 文件路径 1&lt;a href="xxx.html" download&gt;QQ&lt;/a&gt; 相对路径，点击可打开同目录下的xxx.html form 标签 表单 跳转页面（HTTP POST 请求） 属性见 MDN： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form 12345&lt;form action="users" method="post"&gt; &lt;input type="text" name="username"&gt; &lt;input type="password" name="password"&gt; &lt;input type="submit" value="提交"&gt;&lt;/form&gt; 使用注意事项 如果form里没提交按钮就不能提交。 向users路径发送post请求。 若输入xxx和yyy并提交，发送post请求的第四部分数据为username=xxx&amp;password=yyy若输入的是中文并提交，发送post请求的数据 xxx和yyy 会转义为utf-8字符。 name 必须 要写，不写的话提交的时候不会带上你的数据。 input / button 输入 / 按钮 区别：是否为「空标签」 input 的属性见： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input button 的属性见： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button 使用注意事项 如果一个form里只有一个按钮 1234&lt;button&gt;提交&lt;/button&gt; 则浏览器会默认为type = "submit"，是一个普通的按钮&lt;button type= "button" &gt;提交&lt;/button&gt; 不会提交，是一个普通的按钮&lt;input type= "submit" value="提交"&gt; 是一个提交按钮&lt;input value="提交"&gt; 不会提交，是一个普通的按钮 实现点击文字勾上复选框 1&lt;input type=”checkbox” id=”XXX”&gt;&lt;label for=”XXX”&gt;你好&lt;/label&gt; 点击&quot;你好&quot;，复选框也一起勾选了 123&lt;label&gt;用户名&lt;input type=”text” name=”username”&gt;&lt;/label&gt; &lt;label&gt;密码&lt;input type=”password” name=”password”&gt;&lt;/label&gt; &lt;label&gt;&lt;input type=”checkbox” name=”agree”&gt;同意&lt;/label&gt; 用label把input包住，也能实现点击文字勾上复选框。 name一定要写的一样，才能复选 / 单选，并在发送请求时提交到服务器。 1234&lt;label&gt;&lt;input type=”checkBox” name=”fruit” value="yes"&gt;香蕉&lt;/label&gt;&lt;label&gt;&lt;input type=”checkBox” name=”fruit” value="no"&gt;橘子&lt;/label&gt; &lt;label&gt;&lt;input type=”radio” name=”YorN” value="yes"&gt;Yes&lt;/label&gt;&lt;label&gt;&lt;input type=”radio” name=”YorN” value="no"&gt;No&lt;/label&gt; table 标签 表格 用于展示数据 属性见： https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table 相关概念thead：表头（表格标题及头部信息不等）tbody：表中（表格显示的内容部分）tfoot：表尾（表格说明与备注部分）tr：行th：单元格，作为行或列的标题呈现td：单元格，作为内容单元格呈现caption：表格主标题，位于表格之外 表格常用属性width/height：设置宽度/高度border：设置边框align：设置表格对齐方式（left/center/right）cellspacing：设置单元格与单元格之间的间距cellpadding：设置单元格与内容之间的间距bgcolor：设置表格背景颜色background：设置背景图片colspan：跨列 ‘’rowspan：跨行 ‘’ HTML其他常见标签文本标签 标题：h1~h6 文本：span 段落：p 强调：em 粗体：b 斜体：i 删除线：s 上标：sup 下标：sub 语义化标签 头部：header 尾部：footer 导航：nav 文章：article 章节：section 侧栏：aside 地址：address 时间：time 标记：mark 布局：div 引用：blockquote 文档主要内容：main （块级标签） 详细信息：details，一般与 summary 标签一起使用，summary 作为details的第一个子标签使用 格式化标签 换行：br 水平分割线：hr img 标签 图片 src：指定图片链接地址（必须） width/height：设置宽度/高度 title：设置图片标题，鼠标悬浮在图片上时显示 alt：设置提示，当图片加载失败时会显示 HTML 元素类别 块级元素（block） 行内元素（inline） 行内块元素（inline-block）。 display：blockblock元素会独占一行，多个block元素会各自新起一行。默认情况下，block元素宽度自动填满其父元素的宽度。block元素可以设置width、height属性。块级元素及时设置了宽度，仍然会独占一行。block元素可以设置margin、padding属性。 display：inlineinline元素不会独占一行，多个相邻的行内元素会排在同一行里，直到一行排列不下，才会新换行，其宽度随元素的内容而变化。inline元素设置width、height属性无效。inline元素的margin和padding属性，水平方向的padding-left、padding-right、margin-left、margin-right都产生边距效果，但竖直方向的padidng-top、padding-bottom、margin-top以及margin-bottom不会产生边距效果。 display：inline-block简单来说就是将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。比如我们可以给一个link（a元素）inline-block属性值，使其具有block的宽度高度特性又具有inline的同行特性。 补充和总结 a标签的一些特别用法，见上文。 input和button的一些使用注意，见上文。 表单提交时，发送请求会带有表单中的数据，name属性必须写，具体见上文form部分。 Contenteditable属性可使元素内容可编辑。 colgroup标签可调整表格各栏的宽度，很方便。 参考博客 https://blog.csdn.net/hierarch_lee/article/details/54236380]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP的请求与响应]]></title>
    <url>%2F2018%2F09%2F11%2FHTTP-intro%2F</url>
    <content type="text"><![CDATA[Server + Client + HTTP* 浏览器负责发起请求 * 服务器在 80 端口接收请求 * 服务器负责返回内容（响应） * 浏览器负责下载响应内容 HTTP 的作用就是指导浏览器和服务器如何进行沟通。 请求请求示例输入以下命令： curl -s -v -H "Allen: xxx" -- "https://www.baidu.com" 请求的内容为： GET / HTTP/1.1 Host: www.baidu.com User-Agent: curl/7.54.0 Accept: */* Allen: xxx 请求的格式1 动词 路径 协议/版本 2 Key1: value1 2 Key2: value2 2 Key3: value3 2 Content-Type: application/x-www-form-urlencoded 2 Host: www.baidu.com 2 User-Agent: curl/7.54.0 3 4 要上传的数据 1. 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 2. 第三部分永远都是一个回车（\n） 3. 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等 4. 这里的路径包括「查询参数」，但不包括「锚点」 5. 如果你没有写路径，那么路径默认为 / 6. 第 2 部分中的 Content-Type 标注了第 4 部分的格式 如何用 Chrome 查看响应1. 打开 Network 2. 地址栏输入网址 3. 在 Network 点击，查看 request，点击「view source」 4. 点击「view source」后可以看到请求的前三部分 5. 如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到 响应请求示例对应上面请求的响应如下： HTTP/1.1 200 OK Accept-Ranges: bytes Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Connection: Keep-Alive Content-Length: 2443 Content-Type: text/html Date: Tue, 10 Oct 2017 09:14:05 GMT Etag: "5886041d-98b" Last-Modified: Mon, 23 Jan 2017 13:24:45 GMT Pragma: no-cache Server: bfe/1.0.8.18 Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/ &lt;!DOCTYPE html&gt; &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 后面太长，省略…… 响应的格式1 协议/版本号 状态码 状态解释 2 Key1: value1 2 Key2: value2 2 Content-Length: 17931 2 Content-Type: text/html 3 4 要下载的内容 * 状态码大概记一下，是服务器对浏览器说的话 * 1xx 不常用 * 2xx 表示成功 * 3xx 表示滚吧 * 4xx 表示你丫错了 * 5xx 表示好吧，我错了 * 状态解释没什么用 * 第 2 部分中的 Content-Type 标注了第 4 部分的格式 * 第 2 部分中的 Content-Type 遵循 MIME 规范 如何用 Chrome 查看响应1. 打开 Network 2. 输入网址 3. 选中第一个响应 4. 查看 Response Headers，点击「view source」 5. 点击「view source」后你会看到响应的前两部分 6. 查看 Response 或者 Preview，你会看到响应的第 4 部分 Chrome开发者工具查看 HTTP 请求与响应可详见：https://www.jianshu.com/p/a08134dbee23 如何使用 curl 命令？在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具，但按传统，习惯称url为下载工具。 语法：# curl [option] [url] 常见参数：-A/--user-agent &lt;string&gt; 设置用户代理发送给服务器 -b/--cookie &lt;name=string/file&gt; cookie字符串或文件读取位置 -c/--cookie-jar &lt;file&gt; 操作结束后把cookie写入到这个文件中 -C/--continue-at &lt;offset&gt; 断点续转 -D/--dump-header &lt;file&gt; 把header信息写入到该文件中 -e/--referer 来源网址 -f/--fail 连接失败时不显示http错误 -o/--output 把输出写到该文件中 -O/--remote-name 把输出写到该文件中，保留远程文件的文件名 -r/--range &lt;range&gt; 检索来自HTTP/1.1或FTP服务器字节范围 -s/--silent 静音模式。不输出任何东西 -T/--upload-file &lt;file&gt; 上传文件 -u/--user &lt;user[:password]&gt; 设置服务器的用户和密码 -w/--write-out [format] 什么输出完成后 -x/--proxy &lt;host[:port]&gt; 在给定的端口上使用HTTP代理 -#/--progress-bar 进度条显示当前的传送状态 curl命令的更多用法可详见：http://man.linuxde.net/curl]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo博客（Next主题）过程中碰到的问题]]></title>
    <url>%2F2018%2F09%2F11%2FHexo%2F</url>
    <content type="text"><![CDATA[该主题的github主页：https://github.com/iissnan/hexo-theme-next 侧边菜单修改却无法访问在next的_config.yml文件中修改menu配置，添加tag和categories选项，但点击会出现404页面。 解决办法：在根目录执行以下命令：12hexo new page "tags" hexo new page "categories" 打开它们并相应添加type: “tags”和type: “categories”，保存 安装搜索功能 Local Search在next的_config.yml文件中修改Local Search的enable: true后，搜索功能仍无效 解决办法：安装 hexo-generator-search和 hexo-generator-searchdb 在根目录下执行以下命令：12$ npm install hexo-generator-search --save$ npm install hexo-generator-searchdb --save 在根目录的_config.yml文件中添加12345search: path: search.xml field: post format: html limit: 10000]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git入门]]></title>
    <url>%2F2018%2F09%2F10%2Fgit%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[git版本控制中几个重要概念1234561.git init 初始化本地仓库 .git2.git add 文件路径，用来将变动加到暂存区3.git commit -v 提交时显示所有diff信息 使用git前配置12345git config --global user.name 你的英文名git config --global user.email 你的邮箱git config --global push.default matchinggit config --global core.quotepath falsegit config --global core.editor "vim" 下面的命令可获得该终端的ssh key1cat ~/.ssh/id_rsa.pub 常用命令123456789101112git init //不要在已经初始化好的仓库使用，否则会将已经初始化完成的仓库覆盖git status //查看状态git add //提交文件放入暂存区git commit //将暂存区的更新提交到本地仓库git push origin master //把当前本地仓库里的改动推送到远程仓库（origin）的master分支。之后可以直接git push。git pull //当远程仓库有变动但是本地仓库没有更新，会拒绝git push， 使用git pull将远程仓库拉到本地仓库，合并变动。git push -f origin master //强制推送，会覆盖别人的代码git remote add xxx git@xxx.git //再次添加一个远程仓库的标签git push xxx master //推送到xxx标签的地址git remote remove xxx //删除xxx标签git remote set-url origin url //修改origin标签对应的地址git remote rename xxx coding //把xxx标签名修改为coding 实例打开 git bash，进入某目录后输入以下命令：12345cd blog -- 进入blog文件夹git init -- 初始化本地仓库，创建.git目录touch index.html -- 添加index.html文件git add index.html -- 将文件添加到暂存区 (也可以使用git add . 表示将当前目录内所有改动都加入暂存区)git commit index.html -m '添加index.html' 告诉 git，这些文件我要加到仓库里(也可以一次性git commit -m "添加所有改动文件")]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git几个常用命令和一个命令查询工具]]></title>
    <url>%2F2018%2F09%2F10%2Fgit%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[几个常用命令的使用方法ls 罗列* ls 路径 显示所有文件 * ls -a 路径 显示所有目录和文件（文件或目录名称为“.”的视为隐藏，不会列出）； * ls -l 路径 以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等； * ls -al 路径 在ls -l的基础上多显示以“.“开头的隐藏文件； cat 显示文件内容* cat m1 在屏幕上显示文件ml的内容 * cat m1 m2 同时显示文件ml和m2的内容 * cat m1 m2 &gt; file 将文件ml和m2合并后放入文件file中 mv 移动 / 重命名* mv 源路径 目标路径 将某文件从源路径移动至目标路径 * mv 1.txt 2.txt 把 1.txt 移到 2.txt ，也就是重命名 touch 触摸* touch 1.txt 创建1.txt文件 或 改变该文件的更新时间 explainshell.com 的使用 想知道某个命令的用法，搜索该命令就能展示其所有的用法。 在输入框内输入一段命令，这个网站就能帮助你解析该命令是如何工作的，简洁易懂。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
